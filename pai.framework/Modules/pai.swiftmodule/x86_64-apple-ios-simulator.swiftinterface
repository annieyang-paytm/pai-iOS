// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name pai
import CommonCrypto
import CoreData
import CoreLocation
import DataCompression
import Dispatch
import FirebaseCore
import FirebaseCrashlytics
import FirebaseMessaging
import Foundation
import Swift
import SystemConfiguration
import UIKit
import UserNotifications
import os
public class DecodableSerializer : pai.JobInfoSerializer {
  public init(encoder: Foundation.JSONEncoder = JSONEncoder(), decoder: Foundation.JSONDecoder = JSONDecoder())
  public func serialize(info: pai.JobInfo) throws -> Swift.String
  public func deserialize(json: Swift.String) throws -> pai.JobInfo
  @objc deinit
}
extension JobInfo : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension JobInfo : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@objc open class CornerRoundingView : UIKit.UIView {
  @objc @IBInspectable open var cornerRadius: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable open var roundsLeadingCorners: Swift.Bool
  open var roundedCorners: UIKit.UIRectCorner {
    get
    set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open func layoutSubviews()
  @objc deinit
}
extension Limit : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Limit : Swift.Equatable {
  public static func == (lhs: pai.Limit, rhs: pai.Limit) -> Swift.Bool
}
final public class JobBuilder {
  public init(type: Swift.String)
  final public func singleInstance(forId: Swift.String, override: Swift.Bool = false, includeExecutingJob: Swift.Bool = true) -> Self
  @available(*, deprecated, renamed: "parallel")
  final public func group(name: Swift.String) -> Self
  final public func parallel(queueName: Swift.String) -> Self
  final public func delay(time: Foundation.TimeInterval) -> Self
  final public func deadline(date: Foundation.Date) -> Self
  final public func periodic(limit: pai.Limit = .unlimited, interval: Foundation.TimeInterval = 0) -> Self
  final public func internet(atLeast: pai.NetworkType) -> Self
  final public func persist(required: Swift.Bool) -> Self
  final public func retry(limit: pai.Limit) -> Self
  final public func addTag(tag: Swift.String) -> Self
  final public func with(params: [Swift.String : Any]) -> Self
  final public func requireCharging(value: Swift.Bool) -> Self
  final public func schedule(manager: pai.SwiftQueueManager)
  @objc deinit
}
public enum PNFlashMode : Swift.Int {
  case defaultMode
  case instantDisplayMode
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum PNSDKMode : Swift.Int {
  case serverLogin
  case clientLogin
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum PNInboxMessageReadStatus : Swift.String {
  case read
  case unread
  case deleted
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
@objc public class PNUser : ObjectiveC.NSObject {
  public init(userId: Swift.String, ssoToken: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
@objc open class PNNotificationServiceExtension : UserNotifications.UNNotificationServiceExtension {
  @objc override dynamic open func didReceive(_ request: UserNotifications.UNNotificationRequest, withContentHandler contentHandler: @escaping (UserNotifications.UNNotificationContent) -> Swift.Void)
  @objc override dynamic open func serviceExtensionTimeWillExpire()
  open func start() -> pai.PNExtesnionConfig?
  @available(*, deprecated, message: "No longer needed, going to delete it soon")
  open func handleSDKFailure(_ request: UserNotifications.UNNotificationRequest, withContentHandler contentHandler: @escaping (UserNotifications.UNNotificationContent) -> Swift.Void)
  @objc override dynamic public init()
  @objc deinit
}
public struct PNExtesnionConfig {
  public init(appGroupName: Swift.String, clientId: Swift.String, hMacKey: Swift.String)
}
precedencegroup OptionalAssignment {
  associativity: right
}
infix operator ?= : OptionalAssignment
public class UserDefaultsPersister : pai.JobPersister {
  public init(key: Swift.String = "SwiftQueueInfo")
  public func restore() -> [Swift.String]
  public func restore(queueName: Swift.String) -> [Swift.String]
  public func put(queueName: Swift.String, taskId: Swift.String, data: Swift.String)
  public func remove(queueName: Swift.String, taskId: Swift.String)
  @objc deinit
}
@objc public class PNSignalBaseSession : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
public struct PNConstantsStore {
  public struct PushNotificationKeys {
    public static let inboxListUpdatedNotification: Swift.String
  }
  public struct Misc {
  }
}
public enum NetworkType : Swift.Int, Swift.Codable {
  case any
  case cellular
  case wifi
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum RetryConstraint {
  case retry(delay: Foundation.TimeInterval)
  case cancel
  case exponential(initial: Foundation.TimeInterval)
}
public struct JobInfo {
}
public class PNInboxMessage : Swift.CustomStringConvertible, Swift.Hashable {
  final public let pushId: Swift.String
  final public let customerId: Swift.String
  public var readStatus: pai.PNInboxMessageReadStatus? {
    get
    }
  public var receivedTime: Foundation.Date? {
    get
    }
  public var payload: [Swift.AnyHashable : Any]? {
    get
    }
  public var title: Swift.String? {
    get
    }
  public var body: Swift.String? {
    get
    }
  public var expiryDate: Foundation.Date? {
    get
    }
  public var deepLink: pai.PNDeeplink? {
    get
    }
  public var extra: [Swift.AnyHashable : Any]? {
    get
    }
  public var imageURL: Swift.String? {
    get
    }
  public var description: Swift.String {
    get
  }
  public func isUnread() -> Swift.Bool
  public func isDeleted() -> Swift.Bool
  public func isRead() -> Swift.Bool
  public static func == (lhs: pai.PNInboxMessage, rhs: pai.PNInboxMessage) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
public class PNCrashlyticsTrackingError : Swift.Error {
  final public let fileInfo: Swift.String
  public var failureReason: Swift.String
  public var errorCode: Swift.Int
  final public let apiEndPoint: Swift.String?
  @objc deinit
}
public class PNPushNotification {
  @objc deinit
}
public class PNSilentNotification {
  final public let userInfo: [Swift.AnyHashable : Any]
  final public let extraInfo: [Swift.AnyHashable : Any]?
  @objc deinit
}
public class V1Serializer : pai.JobInfoSerializer {
  public func serialize(info: pai.JobInfo) throws -> Swift.String
  public func deserialize(json: Swift.String) throws -> pai.JobInfo
  @objc deinit
}
public class PNPushButton {
  final public let groupId: Swift.String
  final public let buttonId: Swift.String
  final public let title: Swift.String
  final public let type: Swift.String?
  @objc deinit
}
public protocol JobCreator {
  func create(type: Swift.String, params: [Swift.String : Any]?) -> pai.Job
}
public protocol QueueCreator {
  func create(queueName: Swift.String) -> pai.Queue
}
public protocol JobPersister {
  func restore() -> [Swift.String]
  func restore(queueName: Swift.String) -> [Swift.String]
  func put(queueName: Swift.String, taskId: Swift.String, data: Swift.String)
  func remove(queueName: Swift.String, taskId: Swift.String)
}
public protocol JobInfoSerializer {
  func serialize(info: pai.JobInfo) throws -> Swift.String
  func deserialize(json: Swift.String) throws -> pai.JobInfo
}
public protocol JobResult {
  func done(_ result: pai.JobCompletion)
}
public enum JobCompletion {
  case success
  case fail(Swift.Error)
}
public protocol Job {
  func onRun(callback: pai.JobResult)
  func onRetry(error: Swift.Error) -> pai.RetryConstraint
  func onRemove(result: pai.JobCompletion)
}
public protocol Queue {
  var name: Swift.String { get }
  var maxConcurrent: Swift.Int { get }
}
public enum BasicQueue {
  case synchronous
  case concurrent
  case custom(Swift.String)
}
public class BasicQueueCreator : pai.QueueCreator {
  public init()
  public func create(queueName: Swift.String) -> pai.Queue
  @objc deinit
}
extension BasicQueue : pai.Queue {
  public var name: Swift.String {
    get
  }
  public var maxConcurrent: Swift.Int {
    get
  }
}
public protocol JobListener {
  func onBeforeRun(job: pai.JobInfo)
  func onAfterRun(job: pai.JobInfo, result: pai.JobCompletion)
  func onTerminated(job: pai.JobInfo, result: pai.JobCompletion)
}
public enum Limit {
  case unlimited
  case limited(Swift.Double)
}
public enum SwiftQueueError : Swift.Error {
  case canceled
  case deadline
  case duplicate
  case onRetryCancel(Swift.Error)
}
final public class SwiftQueueManager {
  final public var isSuspended: Swift.Bool {
    get
    set
  }
  final public func cancelAllOperations()
  final public func cancelOperations(tag: Swift.String)
  final public func cancelOperations(uuid: Swift.String)
  final public func waitUntilAllOperationsAreFinished()
  final public func queueCount() -> Swift.Int
  final public func jobCount() -> Swift.Int
  @objc deinit
}
final public class SwiftQueueManagerBuilder {
  public init(creator: pai.JobCreator, queueCreator: pai.QueueCreator = BasicQueueCreator())
  final public func set(persister: pai.JobPersister) -> Self
  final public func set(serializer: pai.JobInfoSerializer) -> Self
  final public func set(logger: pai.SwiftQueueLogger) -> Self
  final public func set(isSuspended: Swift.Bool) -> Self
  @available(*, deprecated, renamed: "initInBackground")
  final public func set(synchronous: Swift.Bool) -> Self
  final public func set(initInBackground: Swift.Bool) -> Self
  final public func set(listener: pai.JobListener) -> Self
  final public func build() -> pai.SwiftQueueManager
  @objc deinit
}
@objc public class PNNotificationManager : ObjectiveC.NSObject {
  public static let shared: pai.PNNotificationManager
  public var delegate: pai.PNPTMPushNotificationDelegate?
  public var debugEnabled: Swift.Bool {
    get
    set
  }
  public func start(appGroupName: Swift.String, clientId: Swift.String, key: Swift.String, loggedInUserId: Swift.String? = nil, firebaseConfigFile: Swift.String? = nil, isStaging: Swift.Bool = false, sdkMode: pai.PNSDKMode = .serverLogin, configEndPoint: Swift.String, flashMode: pai.PNFlashMode = .defaultMode, flashPrimaryColorInHex: Swift.String? = nil, flashSecondaryColorInHex: Swift.String? = nil)
  public func deleteSavedData(completion: ((Swift.Bool) -> Swift.Void)?)
  public func checkBuildStatus(isStaging: Swift.Bool, completion: ((Swift.Bool) -> ())?)
  @available(*, deprecated, renamed: "shared")
  public static func sharedInstance() -> pai.PNNotificationManager
  @objc deinit
}
extension PNNotificationManager {
  public func getFCMToken() -> Swift.String?
  public func getChannel() -> pai.PNChannel?
  public func getDeviceId() -> Swift.String?
}
extension PNNotificationManager {
  public func application(_ application: UIKit.UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Foundation.Data)
  public func application(_ application: UIKit.UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Swift.Error)
  public func application(_ application: UIKit.UIApplication?, receiveRemoteNotification userInfo: [Swift.AnyHashable : Any]?, handler completionHandler: ((UIKit.UIBackgroundFetchResult) -> Swift.Void)?)
  public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, willPresent notification: UserNotifications.UNNotification, withCompletionHandler completionHandler: @escaping (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
  public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, didReceive response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)
}
extension PNNotificationManager {
  public func login(user: Swift.String)
  public func logout()
  public func isUserIdAvailable() -> Swift.Bool
}
extension PNNotificationManager {
  @available(*, deprecated, renamed: "inboxMessageList")
  public func fetchInboxMessages() -> [pai.PNInboxMessage]
  public func inboxMessageList() -> [pai.PNInboxMessage]
  public func syncInboxMessages()
  public func markInboxAllMessagesRead()
  public func markMessagesRead(inboxMessages: [pai.PNInboxMessage])
  @available(*, deprecated, renamed: "markMessagesRead(inboxMessages:)", message: "You're encouraged to use the renamed version of this api which doesn't provide the completion block anymore,\nin the new api, mark as read operations will be queued and dispatched more efficiently by the SDK itself so\nthat you don't need to worry about when or how it completes, the SDK will handle any error occurred")
  public func markMessagesRead(inboxMessages: [pai.PNInboxMessage], completion: ((Swift.Bool) -> ())?)
  public func markMessagesUnRead(inboxMessages: [pai.PNInboxMessage], completion: ((Swift.Bool) -> ())?)
  public func delete(inboxMessages: [pai.PNInboxMessage], completion: ((Swift.Bool) -> ())?)
  public func didClicked(message: pai.PNInboxMessage, initiateDeepLink: Swift.Bool)
  public func messageDisplayed(message: pai.PNInboxMessage)
}
extension PNNotificationManager {
  public func flashViewRemoved()
}
@objc public class PNSignalSession : pai.PNSignalBaseSession {
  @objc override dynamic public init()
  @objc deinit
}
public enum LogLevel : Swift.Int {
  case verbose
  case warning
  case error
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension LogLevel {
  public var description: Swift.String {
    get
  }
}
public protocol SwiftQueueLogger {
  func log(_ level: pai.LogLevel, jobId: @autoclosure () -> Swift.String, message: @autoclosure () -> Swift.String)
}
open class ConsoleLogger : pai.SwiftQueueLogger {
  public init(min: pai.LogLevel = .verbose)
  final public func log(_ level: pai.LogLevel, jobId: @autoclosure () -> Swift.String, message: @autoclosure () -> Swift.String)
  open func printComputed(output: Swift.String)
  @objc deinit
}
public class NoLogger : pai.SwiftQueueLogger {
  public static let shared: pai.NoLogger
  public func log(_ level: pai.LogLevel, jobId: @autoclosure () -> Swift.String, message: @autoclosure () -> Swift.String)
  @objc deinit
}
public protocol PNPTMPushNotificationDelegate {
  func deviceLanguage() -> Swift.String?
  func received(deepLink: pai.PNDeeplink?)
  func topViewController() -> UIKit.UIViewController?
  func sharedApplication() -> UIKit.UIApplication?
  func didRecieve(channel: pai.PNChannel)
  func receivedSilentPush(_ silentNotification: pai.PNSilentNotification)
  func willDisplayFlashMessage(with payload: [Swift.AnyHashable : Any]?, appearanceConfigurator: pai.PNFlashAppearanceConfigurator)
  func didDisplayFlashMessage(with payload: [Swift.AnyHashable : Any]?)
  func inboxListUpdated()
  func logSDKGeneric(error: pai.PNCrashlyticsTrackingError)
  func firebaseConfigrationDone()
}
extension PNPTMPushNotificationDelegate {
  public func logSDKGeneric(error: pai.PNCrashlyticsTrackingError)
  public func inboxListUpdated()
  public func willDisplayFlashMessage(with payload: [Swift.AnyHashable : Any]?, appearanceConfigurator: pai.PNFlashAppearanceConfigurator)
  public func didDisplayFlashMessage(with payload: [Swift.AnyHashable : Any]?)
  public func firebaseConfigrationDone()
}
extension UIColor {
  convenience public init?(hex: Swift.String)
}
@objc public class PNSignalConfiguration : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@objc public class PNSignalDispatcher : ObjectiveC.NSObject {
  public static let shared: pai.PNSignalDispatcher
  @objc override dynamic public init()
  @objc deinit
}
@objc final public class PNSignalLog : ObjectiveC.NSObject, Foundation.NSCoding {
  @objc final public func encode(with aCoder: Foundation.NSCoder)
  @objc public init?(coder aDecoder: Foundation.NSCoder)
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
public class PNFlashAppearanceConfigurator {
  public func updateFlashMessageAppearance(fontColor: UIKit.UIColor?, backgroundColor: UIKit.UIColor?)
  public func updateFlashMessageAppearance(fontColorHex: Swift.String, backgroundColorHex: Swift.String)
  @objc deinit
}
public class PNDeeplink {
  public var deepLinkString: Swift.String?
  public var deepLinkDict: Swift.Dictionary<Swift.AnyHashable, Any>?
  @objc deinit
}
public class PNChannel {
  final public let channelId: Swift.String
  @objc deinit
}
extension pai.PNFlashMode : Swift.Equatable {}
extension pai.PNFlashMode : Swift.Hashable {}
extension pai.PNFlashMode : Swift.RawRepresentable {}
extension pai.PNSDKMode : Swift.Hashable {}
extension pai.PNSDKMode : Swift.RawRepresentable {}
extension pai.PNInboxMessageReadStatus : Swift.Equatable {}
extension pai.PNInboxMessageReadStatus : Swift.Hashable {}
extension pai.PNInboxMessageReadStatus : Swift.RawRepresentable {}
extension pai.NetworkType : Swift.Equatable {}
extension pai.NetworkType : Swift.Hashable {}
extension pai.NetworkType : Swift.RawRepresentable {}
extension pai.LogLevel : Swift.Equatable {}
extension pai.LogLevel : Swift.Hashable {}
extension pai.LogLevel : Swift.RawRepresentable {}
