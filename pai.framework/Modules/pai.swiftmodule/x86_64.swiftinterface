// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.2.4 effective-4.1.50 (swiftlang-1103.0.32.9 clang-1103.0.32.53)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 4 -enforce-exclusivity=checked -O -module-name pai
import CommonCrypto
import CoreData
import CoreLocation
import CoreServices
import DataCompression
import Dispatch
import FirebaseCore
import FirebaseMessaging
import Foundation
import SQLite
import Swift
import SystemConfiguration
import UIKit
import UserNotifications
public class DecodableSerializer : pai.JobInfoSerializer {
  public init(encoder: Foundation.JSONEncoder = JSONEncoder(), decoder: Foundation.JSONDecoder = JSONDecoder())
  public func serialize(info: pai.JobInfo) throws -> Swift.String
  public func deserialize(json: Swift.String) throws -> pai.JobInfo
  @objc deinit
}
extension JobInfo : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension JobInfo : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@objc @_inheritsConvenienceInitializers open class CornerRoundingView : UIKit.UIView {
  @objc @IBInspectable open var cornerRadius: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable open var roundsLeadingCorners: Swift.Bool
  open var roundedCorners: UIKit.UIRectCorner {
    get
    set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open func layoutSubviews()
  @objc deinit
}
extension Limit : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Limit : Swift.Equatable {
  public static func == (lhs: pai.Limit, rhs: pai.Limit) -> Swift.Bool
}
final public class JobBuilder {
  public init(type: Swift.String)
  final public func singleInstance(forId: Swift.String, override: Swift.Bool = false, includeExecutingJob: Swift.Bool = true) -> Self
  @available(*, deprecated, renamed: "parallel")
  final public func group(name: Swift.String) -> Self
  final public func parallel(queueName: Swift.String) -> Self
  final public func delay(time: Foundation.TimeInterval) -> Self
  final public func deadline(date: Foundation.Date) -> Self
  final public func periodic(limit: pai.Limit = .unlimited, interval: Foundation.TimeInterval = 0) -> Self
  final public func internet(atLeast: pai.NetworkType) -> Self
  final public func persist(required: Swift.Bool) -> Self
  final public func retry(limit: pai.Limit) -> Self
  final public func addTag(tag: Swift.String) -> Self
  final public func with(params: [Swift.String : Any]) -> Self
  final public func requireCharging(value: Swift.Bool) -> Self
  final public func schedule(manager: pai.SwiftQueueManager)
  @objc deinit
}
@objc public class PNUser : ObjectiveC.NSObject {
  public init(userId: Swift.String, ssoToken: Swift.String)
  @objc deinit
  @objc override dynamic public init()
}
@objc @_inheritsConvenienceInitializers open class PNNotificationServiceExtension : UserNotifications.UNNotificationServiceExtension {
  @objc override dynamic open func didReceive(_ request: UserNotifications.UNNotificationRequest, withContentHandler contentHandler: @escaping (UserNotifications.UNNotificationContent) -> Swift.Void)
  @objc override dynamic open func serviceExtensionTimeWillExpire()
  open func start() -> pai.PNExtesnionConfig?
  open func handleSDKFailure(_ request: UserNotifications.UNNotificationRequest, withContentHandler contentHandler: @escaping (UserNotifications.UNNotificationContent) -> Swift.Void)
  open func handleServiceExtensionTimeWillExpire()
  open func getHmacKey(isStaging: Swift.Bool) -> Swift.String?
  @objc deinit
  @objc override dynamic public init()
}
public struct PNExtesnionConfig {
  public init(appGroupName: Swift.String, clientId: Swift.String, hMacKey: Swift.String)
}
precedencegroup OptionalAssignment {
  associativity: right
}
infix operator ?= : OptionalAssignment
public class UserDefaultsPersister : pai.JobPersister {
  public init(key: Swift.String = "SwiftQueueInfo")
  public func restore() -> [Swift.String]
  public func restore(queueName: Swift.String) -> [Swift.String]
  public func put(queueName: Swift.String, taskId: Swift.String, data: Swift.String)
  public func remove(queueName: Swift.String, taskId: Swift.String)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class PNSignalBaseSession : ObjectiveC.NSObject {
  @objc deinit
  @objc override dynamic public init()
}
public enum NetworkType : Swift.Int, Swift.Codable {
  case any
  case cellular
  case wifi
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum RetryConstraint {
  case retry(delay: Foundation.TimeInterval)
  case cancel
  case exponential(initial: Foundation.TimeInterval)
}
public struct JobInfo {
}
@_hasMissingDesignatedInitializers public class PNInboxMessage : Swift.CustomStringConvertible, Swift.Hashable {
  final public let pushId: Swift.String
  final public let customerId: Swift.String
  public var readStatus: pai.PNInboxMessageReadStatus? {
    get
  }
  public var receivedTime: Foundation.Date? {
    get
  }
  public var payload: [Swift.AnyHashable : Any]? {
    get
  }
  public var title: Swift.String? {
    get
  }
  public var body: Swift.String? {
    get
  }
  public var expiryDate: Foundation.Date? {
    get
  }
  public var deepLink: pai.PNDeeplink? {
    get
  }
  public var extra: [Swift.AnyHashable : Any]? {
    get
  }
  public var imageURL: Swift.String? {
    get
  }
  public var description: Swift.String {
    get
  }
  public func isUnread() -> Swift.Bool
  public func isDeleted() -> Swift.Bool
  public func isRead() -> Swift.Bool
  public static func == (lhs: pai.PNInboxMessage, rhs: pai.PNInboxMessage) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class PNPushNotification {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class PNSilentNotification {
  final public let customerId: Swift.String?
  final public let userInfo: [Swift.AnyHashable : Any]
  final public let extraInfo: [Swift.AnyHashable : Any]?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class V1Serializer : pai.JobInfoSerializer {
  public func serialize(info: pai.JobInfo) throws -> Swift.String
  public func deserialize(json: Swift.String) throws -> pai.JobInfo
  @objc deinit
}
@_hasMissingDesignatedInitializers public class PNPushButton {
  final public let groupId: Swift.String
  final public let buttonId: Swift.String
  final public let title: Swift.String
  final public let type: Swift.String?
  @objc deinit
}
public protocol JobCreator {
  func create(type: Swift.String, params: [Swift.String : Any]?) -> pai.Job
}
public protocol QueueCreator {
  func create(queueName: Swift.String) -> pai.Queue
}
public protocol JobPersister {
  func restore() -> [Swift.String]
  func restore(queueName: Swift.String) -> [Swift.String]
  func put(queueName: Swift.String, taskId: Swift.String, data: Swift.String)
  func remove(queueName: Swift.String, taskId: Swift.String)
}
public protocol JobInfoSerializer {
  func serialize(info: pai.JobInfo) throws -> Swift.String
  func deserialize(json: Swift.String) throws -> pai.JobInfo
}
public protocol JobResult {
  func done(_ result: pai.JobCompletion)
}
public enum JobCompletion {
  case success
  case fail(Swift.Error)
}
public protocol Job {
  func onRun(callback: pai.JobResult)
  func onRetry(error: Swift.Error) -> pai.RetryConstraint
  func onRemove(result: pai.JobCompletion)
}
public protocol Queue {
  var name: Swift.String { get }
  var maxConcurrent: Swift.Int { get }
}
public enum BasicQueue {
  case synchronous
  case concurrent
  case custom(Swift.String)
}
public class BasicQueueCreator : pai.QueueCreator {
  public init()
  public func create(queueName: Swift.String) -> pai.Queue
  @objc deinit
}
extension BasicQueue : pai.Queue {
  public var name: Swift.String {
    get
  }
  public var maxConcurrent: Swift.Int {
    get
  }
}
public protocol JobListener {
  func onBeforeRun(job: pai.JobInfo)
  func onAfterRun(job: pai.JobInfo, result: pai.JobCompletion)
  func onTerminated(job: pai.JobInfo, result: pai.JobCompletion)
}
public enum Limit {
  case unlimited
  case limited(Swift.Double)
}
public enum SwiftQueueError : Swift.Error {
  case canceled
  case deadline
  case duplicate
  case onRetryCancel(Swift.Error)
}
@_hasMissingDesignatedInitializers final public class SwiftQueueManager {
  final public var isSuspended: Swift.Bool {
    get
    set
  }
  final public func cancelAllOperations()
  final public func cancelOperations(tag: Swift.String)
  final public func cancelOperations(uuid: Swift.String)
  final public func waitUntilAllOperationsAreFinished()
  final public func queueCount() -> Swift.Int
  final public func jobCount() -> Swift.Int
  @objc deinit
}
final public class SwiftQueueManagerBuilder {
  public init(creator: pai.JobCreator, queueCreator: pai.QueueCreator = BasicQueueCreator())
  final public func set(persister: pai.JobPersister) -> Self
  final public func set(serializer: pai.JobInfoSerializer) -> Self
  final public func set(logger: pai.SwiftQueueLogger) -> Self
  final public func set(isSuspended: Swift.Bool) -> Self
  @available(*, deprecated, renamed: "initInBackground")
  final public func set(synchronous: Swift.Bool) -> Self
  final public func set(initInBackground: Swift.Bool) -> Self
  final public func set(listener: pai.JobListener) -> Self
  final public func build() -> pai.SwiftQueueManager
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class PNNotificationManager : ObjectiveC.NSObject {
  public var delegate: pai.PNPTMPushNotificationDelegate?
  public func start(appGroupName: Swift.String, clientId: Swift.String, key: Swift.String, loggedInUserId: Swift.String? = nil, firebaseConfigFile: Swift.String? = nil, isStaging: Swift.Bool = false, sdkMode: pai.PNSDKMode = .serverLogin, configEndPoint: Swift.String? = nil, flashMode: pai.PNFlashMode = .defaultMode, flashPrimaryColorInHex: Swift.String? = nil, flashSecondaryColorInHex: Swift.String? = nil)
  public func deleteConfig(completion: ((Swift.Bool) -> Swift.Void)?)
  public func checkBuildStatus(isStaging: Swift.Bool, completion: ((Swift.Bool) -> ())?)
  public static func sharedInstance() -> pai.PNNotificationManager
  @objc deinit
}
extension PNNotificationManager {
  public func getFCMToken() -> Swift.String?
  public func getChannel() -> pai.PNChannel?
  public func getDeviceId() -> Swift.String?
}
extension PNNotificationManager {
  public func application(_ application: UIKit.UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Foundation.Data)
  public func application(_ application: UIKit.UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Swift.Error)
  public func application(_ application: UIKit.UIApplication?, receiveRemoteNotification userInfo: [Swift.AnyHashable : Any]?, handler completionHandler: ((UIKit.UIBackgroundFetchResult) -> Swift.Void)?)
  public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, willPresent notification: UserNotifications.UNNotification, withCompletionHandler completionHandler: @escaping (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
  public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, didReceive response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)
}
extension PNNotificationManager {
  public func login(user: Swift.String)
  public func logout()
  public func isUserIdAvailable() -> Swift.Bool
}
extension PNNotificationManager {
  public func fetchInboxMessages() -> [pai.PNInboxMessage]
  public func syncInboxMessages()
  public func markMessagesRead(inboxMessages: [pai.PNInboxMessage])
  @available(*, deprecated, renamed: "markMessagesRead(inboxMessages:)", message: "You're encouraged to use the renamed version of this api which doesn't provide the completion block anymore,\nin the new api, mark as read operations will be queued and dispatched more efficiently by the SDK itself so\nthat you don't need to worry about when or how it completes, the SDK will handle any error occurred")
  public func markMessagesRead(inboxMessages: [pai.PNInboxMessage], completion: ((Swift.Bool) -> ())?)
  public func markMessagesUnRead(inboxMessages: [pai.PNInboxMessage], completion: ((Swift.Bool) -> ())?)
  public func delete(inboxMessages: [pai.PNInboxMessage], completion: ((Swift.Bool) -> ())?)
  public func didClicked(message: pai.PNInboxMessage, initiateDeepLink: Swift.Bool)
  public func messageDisplayed(message: pai.PNInboxMessage)
}
extension PNNotificationManager {
  public func flashViewRemoved()
}
public enum PNFlashMode : Swift.Int {
  case defaultMode
  case instantDisplayMode
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum PNSDKMode : Swift.Int {
  case serverLogin
  case clientLogin
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum PNInboxMessageReadStatus : Swift.String {
  case read, unread, deleted
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
@objc @_inheritsConvenienceInitializers public class PNSignalSession : pai.PNSignalBaseSession {
  public static func push(signalLog: pai.PNSignalLog)
  @objc deinit
  @objc override dynamic public init()
}
public enum LogLevel : Swift.Int {
  case verbose
  case warning
  case error
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension LogLevel {
  public var description: Swift.String {
    get
  }
}
public protocol SwiftQueueLogger {
  func log(_ level: pai.LogLevel, jobId: @autoclosure () -> Swift.String, message: @autoclosure () -> Swift.String)
}
open class ConsoleLogger : pai.SwiftQueueLogger {
  public init(min: pai.LogLevel = .verbose)
  final public func log(_ level: pai.LogLevel, jobId: @autoclosure () -> Swift.String, message: @autoclosure () -> Swift.String)
  open func printComputed(output: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class NoLogger : pai.SwiftQueueLogger {
  public static let shared: pai.NoLogger
  public func log(_ level: pai.LogLevel, jobId: @autoclosure () -> Swift.String, message: @autoclosure () -> Swift.String)
  @objc deinit
}
public protocol PNPTMPushNotificationDelegate {
  func deviceLanguage() -> Swift.String?
  func received(deepLink: pai.PNDeeplink?)
  func topViewController() -> UIKit.UIViewController?
  func sharedApplication() -> UIKit.UIApplication?
  func didRecieve(channel: pai.PNChannel)
  func receivedSilentPush(_ silentNotification: pai.PNSilentNotification)
  func willDisplayFlashMessage(with payload: [Swift.AnyHashable : Any]?, appearanceConfigurator: pai.PNFlashAppearanceConfigurator)
  func didDisplayFlashMessage(with payload: [Swift.AnyHashable : Any]?)
  func inboxListUpdated()
}
extension PNPTMPushNotificationDelegate {
  public func inboxListUpdated()
  public func willDisplayFlashMessage(with payload: [Swift.AnyHashable : Any]?, appearanceConfigurator: pai.PNFlashAppearanceConfigurator)
  public func didDisplayFlashMessage(with payload: [Swift.AnyHashable : Any]?)
}
public struct PNConstantsStore {
  public struct PushNotificationKeys {
    public static let inboxListUpdatedNotification: Swift.String
  }
  public struct Misc {
  }
}
extension UIColor {
  convenience public init?(hex: Swift.String)
}
@objc @_inheritsConvenienceInitializers public class PNSignalConfiguration : ObjectiveC.NSObject {
  public static func initializePASignalSession(signalType: pai.PNType, withUniqueIdentifier uniqueIdentifier: Swift.String = PNSignalConstant.PA_EVENT_DEFAULT_UNIQUE_ID, isLogginEnabled loggingEnabled: Swift.Bool = PNSignalConstant.PA_EVENT_DEFAULT_LOGGING_ENABLED, withDispatchStrategy dispatchStrategy: pai.PNDispatchStrategy = PNSignalConstant.PA_EVENT_DEFAULT_DISPATCH_STRATEGY, withDispatchInterval dispatchInterval: Foundation.TimeInterval = PNSignalConstant.PA_NC_DEFAULT_DISPATCH_INTERVAL, andMaxBatchSizeToUpload maxBatchSizeToUpload: Swift.Int = PNSignalConstant.PA_EVENT_DEFAULT_MAX_BATCH_UPLOAD, andMaxBatchSizeToCapture maxBatchSizeToCapture: Swift.Int = PNSignalConstant.PA_EVENT_DEFAULT_MAX_BATCH_CAPTURE, andRequestUrl urlString: Swift.String = "", clientId: Swift.String)
  public static func initializeDatastore(signalType: pai.PNType)
  @objc deinit
  @objc override dynamic public init()
}
@objc @_inheritsConvenienceInitializers public class PNSignalDispatcher : ObjectiveC.NSObject {
  public static let eventSharedDispatcher: pai.PNSignalDispatcher
  public static let pushSharedDispatcher: pai.PNSignalDispatcher
  @objc deinit
  @objc override dynamic public init()
}
extension PNSignalDispatcher {
  public func dispatch()
}
@objc @_inheritsConvenienceInitializers final public class PNSignalLog : ObjectiveC.NSObject, Foundation.NSCoding {
  final public var deviceId: Swift.String?
  final public var payload: [Swift.String : Any]?
  final public var eventType: Swift.String?
  final public var customerId: Swift.String?
  final public var clientId: Swift.String?
  final public var appVersion: Swift.String?
  final public var deviceDateTime: Swift.String?
  @objc override dynamic public init()
  final public func dictionaryRepresentation() -> [Swift.String : Any]
  @objc final public func encode(with aCoder: Foundation.NSCoder)
  @objc public init?(coder aDecoder: Foundation.NSCoder)
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class PNFlashAppearanceConfigurator {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class PNDeeplink {
  public var deepLinkString: Swift.String?
  public var deepLinkDict: Swift.Dictionary<Swift.AnyHashable, Any>?
  @objc deinit
}
public enum PNDispatchStrategy {
  case manual
  case intervalBased
  case background
  public static func == (a: pai.PNDispatchStrategy, b: pai.PNDispatchStrategy) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum PNType {
  case pushSignalSDK
  case eventSignalSDK
  public static func == (a: pai.PNType, b: pai.PNType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc @_inheritsConvenienceInitializers public class PNSignalConstant : ObjectiveC.NSObject {
  public static var PA_NC_DEFAULT_DISPATCH_INTERVAL: Foundation.TimeInterval {
    get
  }
  public static var PA_EVENT_DEFAULT_UNIQUE_ID: Swift.String {
    get
  }
  public static var PA_EVENT_DEFAULT_LOGGING_ENABLED: Swift.Bool {
    get
  }
  public static var PA_EVENT_DEFAULT_DISPATCH_STRATEGY: pai.PNDispatchStrategy {
    get
  }
  public static var PA_EVENT_DEFAULT_DISPATCH_INTERVAL: Foundation.TimeInterval {
    get
  }
  public static var PA_EVENT_DEFAULT_MAX_BATCH_UPLOAD: Swift.Int {
    get
  }
  public static var PA_EVENT_DEFAULT_MAX_BATCH_CAPTURE: Swift.Int {
    get
  }
  public static var PA_DIR_DB_FOLDER: Swift.String {
    get
  }
  public static var PA_DIR_DB_PUSH_SIGNAL_NAME: Swift.String {
    get
  }
  public static var PA_DIR_DB_EVENT_NAME: Swift.String {
    get
  }
  public static var PA_TABLE_NETWORKCALLS: Swift.String {
    get
  }
  public static var PA_TABLE_EVENTS: Swift.String {
    get
  }
  public static var PA_COL_SESSION_ID: Swift.String {
    get
  }
  public static var PA_COL_EVENT_ID: Swift.String {
    get
  }
  public static var PA_COL_EVENT_PRIORITY: Swift.String {
    get
  }
  public static var PA_COL_CUSTOMER_ID: Swift.String {
    get
  }
  public static var PA_COL_EVENT_LOG_TIME: Swift.String {
    get
  }
  public static var PA_COL_EVENT_DATA: Swift.String {
    get
  }
  public static var PA_COL_EVENT_IS_STAGED: Swift.String {
    get
  }
  @objc deinit
  @objc override dynamic public init()
}
@_hasMissingDesignatedInitializers public class PNChannel {
  final public let channelId: Swift.String
  @objc deinit
}
extension pai.NetworkType : Swift.Equatable {}
extension pai.NetworkType : Swift.Hashable {}
extension pai.NetworkType : Swift.RawRepresentable {}
extension pai.PNFlashMode : Swift.Equatable {}
extension pai.PNFlashMode : Swift.Hashable {}
extension pai.PNFlashMode : Swift.RawRepresentable {}
extension pai.PNSDKMode : Swift.Equatable {}
extension pai.PNSDKMode : Swift.Hashable {}
extension pai.PNSDKMode : Swift.RawRepresentable {}
extension pai.PNInboxMessageReadStatus : Swift.Equatable {}
extension pai.PNInboxMessageReadStatus : Swift.Hashable {}
extension pai.PNInboxMessageReadStatus : Swift.RawRepresentable {}
extension pai.LogLevel : Swift.Equatable {}
extension pai.LogLevel : Swift.Hashable {}
extension pai.LogLevel : Swift.RawRepresentable {}
extension pai.PNDispatchStrategy : Swift.Equatable {}
extension pai.PNDispatchStrategy : Swift.Hashable {}
extension pai.PNType : Swift.Equatable {}
extension pai.PNType : Swift.Hashable {}
