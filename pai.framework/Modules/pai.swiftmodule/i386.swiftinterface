// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1.3 effective-4.1.50 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
// swift-module-flags: -target i386-apple-ios10.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 4 -enforce-exclusivity=checked -O -module-name pai
import CommonCrypto
import CoreData
import CoreLocation
import CoreServices
import DataCompression
import Dispatch
import FirebaseCore
import FirebaseMessaging
import Foundation
import SQLite
import Swift
import SystemConfiguration
import UIKit
import UserNotifications
public class DecodableSerializer : pai.JobInfoSerializer {
  public init(encoder: Foundation.JSONEncoder = JSONEncoder(), decoder: Foundation.JSONDecoder = JSONDecoder())
  public func serialize(info: pai.JobInfo) throws -> Swift.String
  public func deserialize(json: Swift.String) throws -> pai.JobInfo
  @objc deinit
}
extension JobInfo : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension JobInfo : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@objc open class CornerRoundingView : UIKit.UIView {
  @objc @IBInspectable open var cornerRadius: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable open var roundsLeadingCorners: Swift.Bool
  open var roundedCorners: UIKit.UIRectCorner {
    get
    set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open func layoutSubviews()
  @objc deinit
}
extension Limit : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Limit : Swift.Equatable {
  public static func == (lhs: pai.Limit, rhs: pai.Limit) -> Swift.Bool
}
final public class JobBuilder {
  public init(type: Swift.String)
  final public func singleInstance(forId: Swift.String, override: Swift.Bool = false, includeExecutingJob: Swift.Bool = true) -> Self
  @available(*, deprecated, renamed: "parallel")
  final public func group(name: Swift.String) -> Self
  final public func parallel(queueName: Swift.String) -> Self
  final public func delay(time: Foundation.TimeInterval) -> Self
  final public func deadline(date: Foundation.Date) -> Self
  final public func periodic(limit: pai.Limit = .unlimited, interval: Foundation.TimeInterval = 0) -> Self
  final public func internet(atLeast: pai.NetworkType) -> Self
  final public func persist(required: Swift.Bool) -> Self
  final public func retry(limit: pai.Limit) -> Self
  final public func addTag(tag: Swift.String) -> Self
  final public func with(params: [Swift.String : Any]) -> Self
  final public func requireCharging(value: Swift.Bool) -> Self
  final public func schedule(manager: pai.SwiftQueueManager)
  @objc deinit
}
@objc @objcMembers public class PNUser : ObjectiveC.NSObject {
  @objc public init(userId: Swift.String, ssoToken: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
@objc open class PNNotificationServiceExtension : UserNotifications.UNNotificationServiceExtension {
  @objc override dynamic open func didReceive(_ request: UserNotifications.UNNotificationRequest, withContentHandler contentHandler: @escaping (UserNotifications.UNNotificationContent) -> Swift.Void)
  @objc override dynamic open func serviceExtensionTimeWillExpire()
  open func start() -> pai.PNExtesnionConfig?
  open func handleSDKFailure(_ request: UserNotifications.UNNotificationRequest, withContentHandler contentHandler: @escaping (UserNotifications.UNNotificationContent) -> Swift.Void)
  open func handleServiceExtensionTimeWillExpire()
  open func getHmacKey(isStaging: Swift.Bool) -> Swift.String?
  @objc override dynamic public init()
  @objc deinit
}
public struct PNExtesnionConfig {
  public init(appGroupName: Swift.String, clientId: Swift.String, hMacKey: Swift.String)
}
public class UserDefaultsPersister : pai.JobPersister {
  public init(key: Swift.String = "SwiftQueueInfo")
  public func restore() -> [Swift.String]
  public func restore(queueName: Swift.String) -> [Swift.String]
  public func put(queueName: Swift.String, taskId: Swift.String, data: Swift.String)
  public func remove(queueName: Swift.String, taskId: Swift.String)
  @objc deinit
}
@objc public class PNSignalBaseSession : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
public enum NetworkType : Swift.Int, Swift.Codable {
  case any
  case cellular
  case wifi
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum RetryConstraint {
  case retry(delay: Foundation.TimeInterval)
  case cancel
  case exponential(initial: Foundation.TimeInterval)
}
public struct JobInfo {
}
@objc @objcMembers public class PNInboxMessage : ObjectiveC.NSObject {
  @objc final public let pushId: Swift.String
  @objc final public let customerId: Swift.String
  public var readStatus: pai.PNInboxMessageReadStatus? {
    get
    }
  @objc public var receivedTime: Foundation.Date? {
    get
    }
  @objc public var payload: Swift.Dictionary<Swift.AnyHashable, Any>? {
    get
    }
  @objc public var title: Swift.String? {
    get
    }
  @objc public var body: Swift.String? {
    get
    }
  @objc public var expiryDate: Foundation.Date? {
    get
    }
  public var deepLink: pai.PNDeeplink? {
    get
    }
  @objc public var extra: Swift.Dictionary<Swift.AnyHashable, Any>? {
    get
    }
  @objc public var imageURL: Swift.String? {
    get
    }
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc public func isUnread() -> Swift.Bool
  @objc public func isDeleted() -> Swift.Bool
  @objc public func isRead() -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public class PNPushNotification {
  @objc deinit
}
public class PNSilentNotification {
  final public let customerId: Swift.String?
  final public let userInfo: [Swift.AnyHashable : Any]
  final public let extraInfo: [Swift.AnyHashable : Any]?
  @objc deinit
}
public class V1Serializer : pai.JobInfoSerializer {
  public func serialize(info: pai.JobInfo) throws -> Swift.String
  public func deserialize(json: Swift.String) throws -> pai.JobInfo
  @objc deinit
}
public class PNPushButton {
  final public let groupId: Swift.String
  final public let buttonId: Swift.String
  final public let title: Swift.String
  final public let type: Swift.String?
  @objc deinit
}
public protocol JobCreator {
  func create(type: Swift.String, params: [Swift.String : Any]?) -> pai.Job
}
public protocol QueueCreator {
  func create(queueName: Swift.String) -> pai.Queue
}
public protocol JobPersister {
  func restore() -> [Swift.String]
  func restore(queueName: Swift.String) -> [Swift.String]
  func put(queueName: Swift.String, taskId: Swift.String, data: Swift.String)
  func remove(queueName: Swift.String, taskId: Swift.String)
}
public protocol JobInfoSerializer {
  func serialize(info: pai.JobInfo) throws -> Swift.String
  func deserialize(json: Swift.String) throws -> pai.JobInfo
}
public protocol JobResult {
  func done(_ result: pai.JobCompletion)
}
public enum JobCompletion {
  case success
  case fail(Swift.Error)
}
public protocol Job {
  func onRun(callback: pai.JobResult)
  func onRetry(error: Swift.Error) -> pai.RetryConstraint
  func onRemove(result: pai.JobCompletion)
}
public protocol Queue {
  var name: Swift.String { get }
  var maxConcurrent: Swift.Int { get }
}
public enum BasicQueue {
  case synchronous
  case concurrent
  case custom(Swift.String)
}
public class BasicQueueCreator : pai.QueueCreator {
  public init()
  public func create(queueName: Swift.String) -> pai.Queue
  @objc deinit
}
extension BasicQueue : pai.Queue {
  public var name: Swift.String {
    get
  }
  public var maxConcurrent: Swift.Int {
    get
  }
}
public protocol JobListener {
  func onBeforeRun(job: pai.JobInfo)
  func onAfterRun(job: pai.JobInfo, result: pai.JobCompletion)
  func onTerminated(job: pai.JobInfo, result: pai.JobCompletion)
}
public enum Limit {
  case unlimited
  case limited(Swift.Double)
}
public enum SwiftQueueError : Swift.Error {
  case canceled
  case deadline
  case duplicate
  case onRetryCancel(Swift.Error)
}
final public class SwiftQueueManager {
  final public var isSuspended: Swift.Bool {
    get
    set
  }
  final public func cancelAllOperations()
  final public func cancelOperations(tag: Swift.String)
  final public func cancelOperations(uuid: Swift.String)
  final public func waitUntilAllOperationsAreFinished()
  final public func queueCount() -> Swift.Int
  final public func jobCount() -> Swift.Int
  @objc deinit
}
final public class SwiftQueueManagerBuilder {
  public init(creator: pai.JobCreator, queueCreator: pai.QueueCreator = BasicQueueCreator())
  final public func set(persister: pai.JobPersister) -> Self
  final public func set(serializer: pai.JobInfoSerializer) -> Self
  final public func set(logger: pai.SwiftQueueLogger) -> Self
  final public func set(isSuspended: Swift.Bool) -> Self
  @available(*, deprecated, renamed: "initInBackground")
  final public func set(synchronous: Swift.Bool) -> Self
  final public func set(initInBackground: Swift.Bool) -> Self
  final public func set(listener: pai.JobListener) -> Self
  final public func build() -> pai.SwiftQueueManager
  @objc deinit
}
@objc @objcMembers public class PNNotificationManager : ObjectiveC.NSObject {
  public var delegate: pai.PNPTMPushNotificationDelegate?
  @objc public static func sharedInstance() -> pai.PNNotificationManager
  @objc deinit
  public func start(appGroupName: Swift.String, clientId: Swift.String, key: Swift.String, loggedInUserId: Swift.String?, firebaseConfigFile: Swift.String? = nil, isStaging: Swift.Bool = false, sdkMode: pai.PNSDKMode = .serverLogin, configEndPoint: Swift.String? = nil, flashMode: pai.PNFlashMode = .defaultMode, flashPrimaryColorInHex: Swift.String? = nil, flashSecondaryColorInHex: Swift.String? = nil)
  @objc public func deleteConfig(completion: ((Swift.Bool) -> Swift.Void)?)
  @objc public func checkBuildStatus(isStaging: Swift.Bool, completion: ((Swift.Bool) -> ())?)
}
extension PNNotificationManager {
  @objc dynamic public func application(_ application: UIKit.UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Foundation.Data)
  @objc dynamic public func application(_ application: UIKit.UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Swift.Error)
  @objc dynamic public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, didReceive response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)
  @objc dynamic public func application(_ application: UIKit.UIApplication?, receiveRemoteNotification userInfo: [Swift.AnyHashable : Any]?, handler completionHandler: ((UIKit.UIBackgroundFetchResult) -> Swift.Void)?)
  @objc dynamic public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, willPresent notification: UserNotifications.UNNotification, withCompletionHandler completionHandler: @escaping (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
}
extension PNNotificationManager {
  @objc dynamic public func login(user: Swift.String)
  @objc dynamic public func logout()
  @objc dynamic public func isUserIdAvailable() -> Swift.Bool
  @objc dynamic public func requiresUpdate(user: pai.PNUser)
}
extension PNNotificationManager {
  @objc dynamic public func fetchInboxMessages() -> [pai.PNInboxMessage]
  @objc dynamic public func syncInboxMessages()
  @objc dynamic public func markMessagesRead(inboxMessages: [pai.PNInboxMessage], completion: ((Swift.Bool) -> ())?)
  @objc dynamic public func markMessagesUnRead(inboxMessages: [pai.PNInboxMessage], completion: ((Swift.Bool) -> ())?)
  @objc dynamic public func delete(inboxMessages: [pai.PNInboxMessage], completion: ((Swift.Bool) -> ())?)
  @objc dynamic public func didClicked(message: pai.PNInboxMessage, initiateDeepLink: Swift.Bool)
  @objc dynamic public func messageDisplayed(message: pai.PNInboxMessage)
}
extension PNNotificationManager {
  @objc dynamic public func flashViewRemoved()
}
extension PNNotificationManager {
  @objc dynamic public func getChannel() -> pai.PNChannel?
}
extension PNNotificationManager {
  @objc dynamic public func getFCMToken() -> Swift.String?
}
extension PNNotificationManager {
  @objc public static let inboxListUpdatedNotification: Swift.String
}
public typealias PNInboxCompletion = (Swift.Array<pai.PNInboxMessage>) -> ()
public enum PNFlashMode : Swift.Int {
  case defaultMode
  case instantDisplayMode
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum PNSDKMode : Swift.Int {
  case serverLogin
  case clientLogin
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum PNInboxMessageReadStatus : Swift.String {
  case read, unread, deleted
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
@objc public class PNSignalSession : pai.PNSignalBaseSession {
  public static func push(signalLog: pai.PNSignalLog)
  @objc override dynamic public init()
  @objc deinit
}
public enum LogLevel : Swift.Int {
  case verbose
  case warning
  case error
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension LogLevel {
  public var description: Swift.String {
    get
  }
}
public protocol SwiftQueueLogger {
  func log(_ level: pai.LogLevel, jobId: @autoclosure () -> Swift.String, message: @autoclosure () -> Swift.String)
}
open class ConsoleLogger : pai.SwiftQueueLogger {
  public init(min: pai.LogLevel = .verbose)
  final public func log(_ level: pai.LogLevel, jobId: @autoclosure () -> Swift.String, message: @autoclosure () -> Swift.String)
  open func printComputed(output: Swift.String)
  @objc deinit
}
public class NoLogger : pai.SwiftQueueLogger {
  public static let shared: pai.NoLogger
  public func log(_ level: pai.LogLevel, jobId: @autoclosure () -> Swift.String, message: @autoclosure () -> Swift.String)
  @objc deinit
}
public typealias NotificationDataCompletion = ([pai.PNPTMPushNotificationDelegate]?) -> ()
public protocol PNPTMPushNotificationDelegate {
  func deviceLanguage() -> Swift.String?
  func received(deepLink: pai.PNDeeplink?)
  func topViewController() -> UIKit.UIViewController?
  func sharedApplication() -> UIKit.UIApplication?
  func didRecieve(channel: pai.PNChannel)
  func receivedSilentPush(_ silentNotification: pai.PNSilentNotification)
  func willDisplayFlashMessage(with payload: [Swift.AnyHashable : Any]?, appearanceConfigurator: pai.PNFlashAppearanceConfigurator)
  func didDisplayFlashMessage(with payload: [Swift.AnyHashable : Any]?)
  func inboxListUpdated()
}
extension PNPTMPushNotificationDelegate {
  public func inboxListUpdated()
  public func willDisplayFlashMessage(with payload: [Swift.AnyHashable : Any]?, appearanceConfigurator: pai.PNFlashAppearanceConfigurator)
  public func didDisplayFlashMessage(with payload: [Swift.AnyHashable : Any]?)
}
extension UIColor {
  convenience public init?(hex: Swift.String)
}
@objc public class PNSignalConfiguration : ObjectiveC.NSObject {
  public static func initializePASignalSession(signalType: pai.PNType, withUniqueIdentifier uniqueIdentifier: Swift.String = PNSignalConstant.PA_EVENT_DEFAULT_UNIQUE_ID, isLogginEnabled loggingEnabled: Swift.Bool = PNSignalConstant.PA_EVENT_DEFAULT_LOGGING_ENABLED, withDispatchStrategy dispatchStrategy: pai.PNDispatchStrategy = PNSignalConstant.PA_EVENT_DEFAULT_DISPATCH_STRATEGY, withDispatchInterval dispatchInterval: Foundation.TimeInterval = PNSignalConstant.PA_NC_DEFAULT_DISPATCH_INTERVAL, andMaxBatchSizeToUpload maxBatchSizeToUpload: Swift.Int = PNSignalConstant.PA_EVENT_DEFAULT_MAX_BATCH_UPLOAD, andMaxBatchSizeToCapture maxBatchSizeToCapture: Swift.Int = PNSignalConstant.PA_EVENT_DEFAULT_MAX_BATCH_CAPTURE, andRequestUrl urlString: Swift.String = "", clientId: Swift.String)
  public static func initializeDatastore(signalType: pai.PNType)
  @objc override dynamic public init()
  @objc deinit
}
@objc public class PNSignalDispatcher : ObjectiveC.NSObject {
  @objc public static let eventSharedDispatcher: pai.PNSignalDispatcher
  @objc public static let pushSharedDispatcher: pai.PNSignalDispatcher
  @objc override dynamic public init()
  @objc deinit
}
extension PNSignalDispatcher {
  @objc dynamic public func dispatch()
}
@objc final public class PNSignalLog : ObjectiveC.NSObject, Foundation.NSCoding {
  @objc override dynamic public init()
  @objc override final public var description: Swift.String {
    @objc get
  }
  final public var deviceId: Swift.String?
  final public var dataTime: Swift.String?
  final public var payload: [Swift.String : Any]?
  final public var eventType: Swift.String?
  final public var customerId: Swift.String?
  final public var clientId: Swift.String?
  final public var appVersion: Swift.String?
  final public func dictionaryRepresentation() -> [Swift.String : Any]
  @objc final public func encode(with aCoder: Foundation.NSCoder)
  @objc public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public class PNFlashAppearanceConfigurator {
  @objc deinit
}
public class PNDeeplink {
  public var deepLinkString: Swift.String?
  public var deepLinkDict: Swift.Dictionary<Swift.AnyHashable, Any>?
  @objc deinit
}
public enum PNDispatchStrategy {
  case manual
  case intervalBased
  case background
  public static func == (a: pai.PNDispatchStrategy, b: pai.PNDispatchStrategy) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum PNType {
  case pushSignalSDK
  case eventSignalSDK
  public static func == (a: pai.PNType, b: pai.PNType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc public class PNSignalConstant : ObjectiveC.NSObject {
  public static var PA_NC_DEFAULT_DISPATCH_INTERVAL: Foundation.TimeInterval {
    get
  }
  public static var PA_EVENT_DEFAULT_UNIQUE_ID: Swift.String {
    get
  }
  public static var PA_EVENT_DEFAULT_LOGGING_ENABLED: Swift.Bool {
    get
  }
  public static var PA_EVENT_DEFAULT_DISPATCH_STRATEGY: pai.PNDispatchStrategy {
    get
  }
  public static var PA_EVENT_DEFAULT_DISPATCH_INTERVAL: Foundation.TimeInterval {
    get
  }
  public static var PA_EVENT_DEFAULT_MAX_BATCH_UPLOAD: Swift.Int {
    get
  }
  public static var PA_EVENT_DEFAULT_MAX_BATCH_CAPTURE: Swift.Int {
    get
  }
  public static var PA_DIR_DB_FOLDER: Swift.String {
    get
  }
  public static var PA_DIR_DB_PUSH_SIGNAL_NAME: Swift.String {
    get
  }
  public static var PA_DIR_DB_EVENT_NAME: Swift.String {
    get
  }
  public static var PA_TABLE_NETWORKCALLS: Swift.String {
    get
  }
  public static var PA_TABLE_EVENTS: Swift.String {
    get
  }
  public static var PA_COL_SESSION_ID: Swift.String {
    get
  }
  public static var PA_COL_EVENT_ID: Swift.String {
    get
  }
  public static var PA_COL_EVENT_PRIORITY: Swift.String {
    get
  }
  public static var PA_COL_CUSTOMER_ID: Swift.String {
    get
  }
  public static var PA_COL_EVENT_LOG_TIME: Swift.String {
    get
  }
  public static var PA_COL_EVENT_DATA: Swift.String {
    get
  }
  public static var PA_COL_EVENT_IS_STAGED: Swift.String {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc public class PNChannel : ObjectiveC.NSObject {
  final public let channelId: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
extension pai.NetworkType : Swift.Equatable {}
extension pai.NetworkType : Swift.Hashable {}
extension pai.NetworkType : Swift.RawRepresentable {}
extension pai.PNFlashMode : Swift.Hashable {}
extension pai.PNFlashMode : Swift.RawRepresentable {}
extension pai.PNSDKMode : Swift.Hashable {}
extension pai.PNSDKMode : Swift.RawRepresentable {}
extension pai.PNInboxMessageReadStatus : Swift.Hashable {}
extension pai.PNInboxMessageReadStatus : Swift.RawRepresentable {}
extension pai.LogLevel : Swift.Equatable {}
extension pai.LogLevel : Swift.Hashable {}
extension pai.LogLevel : Swift.RawRepresentable {}
extension pai.PNDispatchStrategy : Swift.Equatable {}
extension pai.PNDispatchStrategy : Swift.Hashable {}
extension pai.PNType : Swift.Equatable {}
extension pai.PNType : Swift.Hashable {}
